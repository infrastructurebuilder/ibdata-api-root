<model xmlns="http://codehaus-plexus.github.io/MODELLO/1.8.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://codehaus-plexus.github.io/MODELLO/1.8.0 http://codehaus-plexus.github.io/modello/xsd/modello-1.8.0.xsd"
  java.suppressAllWarnings="false"
  xml.namespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}"
  xml.schemaLocation="https://resources.infrastructurebuilder.org/xsd/IBDataSet-${apiVersion}"
  xsd.namespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}"
  xsd.targetNamespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}">
  <id>datasource</id>
  <name>IBDataSourceModel</name>
  <!-- Must be a single (no spaces, no dashes, no periods) identifier in
    order to create reader/writer -->
  <description>Mechanism to read config for an IBDataSource</description>
  <defaults>
    <default>
      <key>package</key>
      <value>${project.groupId}.model</value>
    </default>
  </defaults>
  <versionDefinition>
    <type>field</type>
    <value>modelVersion</value>
  </versionDefinition>
  <classes>
    <!-- MODEL -->

    <class xml.tagName="dataStream"
      java.clone.hook="mutatingDataStreamCloneHook" java.clone="deep">
      <name>DataStream</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataStreamIdentifier]]>
        </interface>
        <interface>
          <![CDATA[java.lang.Comparable<org.infrastructurebuilder.data.IBDataStreamIdentifier>]]>
        </interface>
      </interfaces>
      <description>
        <![CDATA[
        The <code>&lt;dataSet&gt;</code> element contains information about a set of DataStream instances.
        ]]>
      </description>
      <fields>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the datastream, which is the UUID of the bytes of the checksum of the data.</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>name</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the datastream.</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>description</name>
          <version>1.0.0+</version>
          <description>A detailed description of the datastream</description>
          <type>String</type>
        </field>
        <field>
          <name>mimeType</name>
          <version>1.0.0+</version>
          <description>Stringified version of a MIME type for the datastream</description>
          <required>true</required>
          <defaultValue>application/octet-stream</defaultValue>
          <type>String</type>
        </field>
        <field>
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Creation date of this stream, required</description>
          <type>Date</type>
        </field>
        <field java.getter="false">
          <name>url</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>URL of the source of this stream, if available</description>
          <type>String</type>
        </field>
        <field>
          <name>sha512</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Sha-512 Checksum  of the source of this stream</description>
          <type>String</type>
        </field>
        <field>
          <name>path</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Describes a path to the stream</description>
          <type>String</type>
        </field>
        <field>
          <name>structuredDataDescriptor</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Optional DataStreamStructuredMetadata element for datastream</description>
          <association>
            <type>DataStreamStructuredMetadata</type>
            <multiplicity>1</multiplicity>
          </association>
        </field>
        <field>
          <name>originalLength</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Length of the original stream, if known</description>
          <type>String</type>
        </field>
        <field>
          <name>originalRowCount</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Number of rows of the stream</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
        <field java.getter="false">
          <name>provenance</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Datastream provenance</description>
          <association>
            <type>DataStreamProvenance</type>
            <multiplicity>1</multiplicity>
          </association>
        </field>
        <field>
          <name>referencedSchema</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>UUID of schema that this DataStream is meant to map to</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Default constructor
  public DataStream() {
    this.setCreationDate(new java.util.Date());
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // "Copy constructor"
  public DataStream(DataStream ds) {
    this.setCreationDate(ds.getCreationDate());
    this.setDescription(ds.getDescription().orElse(null));
    this.setName(ds.getName().orElse(null));
    this.setMetadata(ds.getMetadata());
    this.setMimeType(ds.getMimeType());
    this.setPath(ds.getPath());
    this.setSha512(ds.getSha512());
    this.setUrl(ds.getUrl().orElse(null));
    this.setUuid(ds.getUuid());
    this.setOriginalLength(ds.getOriginalLength());
    this.setOriginalRowCount(ds.getOriginalRowCount());
    this.setProvenance(ds.getProvenance().map(DataStreamProvenance::new).orElse(null));
    this.setReferencedSchema(ds.getReferencedSchema());
  }

  @Override
  public org.infrastructurebuilder.data.Metadata getMetadata() {
      if (this.metadata == null)
         this.metadata = new org.infrastructurebuilder.data.Metadata();
      if (!(this.metadata instanceof org.infrastructurebuilder.data.Metadata))
        this.metadata = new org.infrastructurebuilder.data.Metadata(this.metadata);
      return (org.infrastructurebuilder.data.Metadata) this.metadata;
  }

            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  private void mutatingDataStreamCloneHook(DataStream s) {
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // hash and equals


  @Override
  public int hashCode() {
    return java.util.Objects.hash(creationDate, description, name, metadata, mimeType, path, sha512,
        url, uuid, originalLength, originalRowCount, provenance, referencedSchema);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    DataStream other = (DataStream) obj;
    return java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(description, other.description)
        && java.util.Objects.equals(name, other.name)
        && java.util.Objects.equals(metadata, other.metadata)
        && java.util.Objects.equals(mimeType, other.mimeType)
        && java.util.Objects.equals(path, other.path)
        && java.util.Objects.equals(sha512, other.sha512)
        && java.util.Objects.equals(url, other.url)
        && java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(originalLength, other.originalLength)
        && java.util.Objects.equals(originalRowCount, other.originalRowCount)
        && java.util.Objects.equals(provenance, other.provenance)
        && java.util.Objects.equals(referencedSchema, other.referencedSchema)
        ;
  }


            ]]>
          </code>
        </codeSegment>


        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int compareTo(org.infrastructurebuilder.data.IBDataStreamIdentifier that) {
    return ibDataStreamComparator.compare(this, that);
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            //
            // ID mapper Work
            //
  @Override
  public java.util.UUID getId() {
     return safeMapUUID.apply(getUuid()).orElse(null);
  }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Typed source url access
  @Override
  public java.util.Optional<String> getUrl() {
    return java.util.Optional.ofNullable(this.url);

  }
  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getName() {
    return java.util.Optional.ofNullable(name);
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<org.infrastructurebuilder.data.IBDataProvenance> getProvenance() {
    return java.util.Optional.ofNullable(provenance);
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getDescription() {
    return java.util.Optional.ofNullable(description);
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  public java.util.Optional<org.infrastructurebuilder.data.IBDataStructuredDataMetadata> getStructuredDataMetadata() {
    return java.util.Optional.ofNullable(this.getStructuredDataDescriptor());
  }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   * Fetch the schema ID
   */
  @Override
  public java.util.Optional<java.util.UUID> getReferencedSchemaId() {
    return safeMapUUID.apply(getReferencedSchema());
  }
          ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  private String temporaryId;  // Never persisted
  /**
   * Set a temporary value to the UUID field for processing
   */
  public void setTemporaryId(String id) {
    this.temporaryId = id;
  }

  public java.util.Optional<String> getTemporaryId() {
    return java.util.Optional.ofNullable(this.temporaryId);
  }

              ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class xml.tagName="dataSet" rootElement="true"
      java.clone.hook="mutatingDataSetCloneHook" java.clone="deep">
      <name>DataSet</name>
      <description>
        <![CDATA[
        The <code>&lt;dataSet&gt;</code> element is the root of the configuration.
        ]]>
      </description>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataSetIdentifier]]>
        </interface>
        <interface>
          <![CDATA[java.lang.Comparable<org.infrastructurebuilder.data.IBDataSetIdentifier>]]>
        </interface>
      </interfaces>
      <fields>

        <!-- ====================================================================== -->
        <!-- DataSet Version -->
        <!-- ====================================================================== -->
        <field>
          <name>modelVersion</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Declares to which version of project descriptor this configuration conforms.  This value is the api version (major.minor) of ibdata-api and conforms to semantic versioning</description>
          <type>String</type>
        </field>


        <field>
          <name>groupId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Namespace of the dataset.  This defaults to the project.groupId of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>artifactId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Artifact Identifier of the dataset.  This defaults to the project.artifactId of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>version</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Version of the dataset.  This defaults to the project.version of the building project</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the dataset.  This is the UUID from the Checksums of all the DataStream elements</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>name</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the dataset.  This defaults to the project.name of the building project</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>description</name>
          <version>1.0.0+</version>
          <description>A detailed description of the dataset.  This defaults to the project.description of the building project</description>
          <type>String</type>
        </field>
        <field xml.format="yyyy-MM-dd'T'HH:mm:ss.SSS"
          java.getter="false">
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>A Date that is very close to the moment when this DataSet was persisted.  It has essentially no relationship to when the streams were read, except that it must be later.</description>
          <type>Date</type>
        </field>
        <field>
          <name>streams</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Instances of DataStreams</description>
          <association>
            <type>DataStream</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field>
          <name>schemas</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Instances of DataSchema</description>
          <association>
            <type>DataSchema</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field java.getter="false">
          <name>path</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes a path to the dataset</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
      </fields>
      <codeSegments>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Default constructor (Must do this if you supply a constructor)
  public DataSet() {
    setCreationDate(new java.util.Date());
//    setStreams(new java.util.ArrayList<>());
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Copy constructor
  public DataSet(DataSet ds) {
    this.setArtifactId(ds.getArtifactId());
    this.setCreationDate(ds.getCreationDate());
    this.setDescription(ds.getDescription().orElse(null));
    this.setName(ds.getName().orElse(null));
    this.setGroupId(ds.getGroupId());
    this.setMetadata(ds.getMetadata());
    this.setModelVersion(ds.getModelVersion());
    this.setPath(ds.getPath().orElse(null));
    this.setStreams(ds.getStreams().stream().map(DataStream::new).collect(java.util.stream.Collectors.toList()));
    this.setUuid(java.util.Optional.ofNullable(ds.getUuid()).map(java.util.UUID::toString).orElse(null));
    this.setVersion(ds.getVersion());
  }

  @Override
  public org.infrastructurebuilder.data.Metadata getMetadata() {
      if (this.metadata == null)
         this.metadata = new org.infrastructurebuilder.data.Metadata();
      if (!(this.metadata instanceof org.infrastructurebuilder.data.Metadata))
        this.metadata = new org.infrastructurebuilder.data.Metadata(this.metadata);
      return (org.infrastructurebuilder.data.Metadata) this.metadata;
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  private void mutatingDataSetCloneHook(DataSet ds) {
    if (streams != null)
      ds.getStreams().forEach(s -> s.setPath(org.infrastructurebuilder.data.IBDataModelUtils.relativizePath(ds, s)));
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  private java.nio.file.Path underlyingPath = null;

  protected DataSet setUnderlyingPath(java.nio.file.Path p) {
    this.underlyingPath = p;
    return this;
  }

  protected java.util.Optional<java.nio.file.Path> underLyingPath() {
    return java.util.Optional.ofNullable(underlyingPath);
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Hashcode and equals
  @Override
  public int hashCode() {
    return java.util.Objects.hash(artifactId, creationDate, description, name, groupId, metadata, modelEncoding,
        modelVersion, path, streams, uuid, version);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    DataSet other = (DataSet) obj;
    return java.util.Objects.equals(artifactId, other.artifactId)
        && java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(description, other.description)
        && java.util.Objects.equals(name, other.name)
        && java.util.Objects.equals(groupId, other.groupId)
        && java.util.Objects.equals(metadata, other.metadata)
        && java.util.Objects.equals(modelEncoding, other.modelEncoding)
        && java.util.Objects.equals(modelVersion, other.modelVersion)
        && java.util.Objects.equals(path, other.path)
        && java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(version, other.version)
        && java.util.Objects.equals(getStreams(), other.getStreams())
        ;
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getName() {
    return java.util.Optional.ofNullable(name);
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getDescription() {
    return java.util.Optional.ofNullable(description);
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getPath() {
    return java.util.Optional.ofNullable(path);
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Date getCreationDate() {
    if (this.creationDate == null)
      this.creationDate = new java.util.Date();
    return this.creationDate;
  }

  ]]>
          </code>
        </codeSegment>



        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int compareTo(org.infrastructurebuilder.data.IBDataSetIdentifier that) {
    return IBDataSetIdentifierComparator.compare(this, that);
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            //
            // ID mapper Work
            //
  @Override
  public java.util.UUID getUuid() {
     return nullableSafeMapUUID.apply(uuid);
  }            ]]>
          </code>
        </codeSegment>
      </codeSegments>

    </class>
    <class locationTracker="locations" java.clone="shallow">
      <name>DataSetInputLocation</name>
      <version>1.0.0+</version>
      <fields>
        <!-- line, column and source fields are auto-generated by Modello -->
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

    @Override
    public String toString()
    {
        return getLineNumber() + " : " + getColumnNumber() + ", " + getSource();
    }
            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class sourceTracker="source" java.clone="shallow">
      <name>DataSetInputSource</name>
      <version>1.0.0+</version>
      <fields>
        <field>
          <name>modelId</name>
          <version>1.0.0+</version>
          <type>String</type>
          <description>
            <![CDATA[
            The identifier of the deployment model in the format {@code <groupId>:<artifactId>:<version>}.
            ]]>
          </description>
        </field>
        <field>
          <name>location</name>
          <version>1.0.0+</version>
          <type>String</type>
          <description>
            <![CDATA[
            The path/URL of the deployment model or {@code null} if unknown.
            ]]>
          </description>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    @Override
    public String toString()
    {
        return getModelId() + " " + getLocation();
    }
            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>

    <class xml.tagName="structuredFieldMetadata"
      java.clone.hook="mutatingCloneHook" java.clone="deep">
      <name>StructuredFieldMetadata</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
                <![CDATA[org.infrastructurebuilder.data.IBDataStructuredDataFieldMetadata]]>
            </interface>
      </interfaces>
      <fields>
        <field>
          <name>index</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Describes the field within the structured metadata that this SFM describes, from a base of 0.  Default value set to -1 to ensure setting proper index</description>
          <type>int</type>
          <defaultValue>-1</defaultValue>
        </field>
        <field java.getter="false">
          <name>max</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes the "maximum length" or "maximum size" of the data in the field.</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>min</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes the "minimum length" or "maximum size" of the data in the field.</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>nulled</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes if the field contains a null value.</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>uniqueValuesCount</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes the number of unique value in the stream data</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public StructuredFieldMetadata() {
    }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public StructuredFieldMetadata(org.infrastructurebuilder.data.IBDataStructuredDataFieldMetadata o) {
      this();
      this.index = o.getIndex();
      this.max = o.getMax().orElse(null);
      this.min = o.getMin().orElse(null);
      this.nulled = java.util.Optional.ofNullable(o.isNulled()).map(a -> a.toString()).orElse(null);
      this.uniqueValuesCount = o.getUniqueValuesCount().map(i -> i.toString()).orElse(null);
      this.parent = o.getParent().orElse(null);
    }
    ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public void mutatingCloneHook(org.infrastructurebuilder.data.IBDataStructuredDataFieldMetadata o) {
      if (o instanceof org.infrastructurebuilder.data.model.StructuredFieldMetadata)
      {
        org.infrastructurebuilder.data.model.StructuredFieldMetadata t = (org.infrastructurebuilder.data.model.StructuredFieldMetadata)o;
        t.index = this.getIndex();
        t.max = this.getMax().orElse(null);
        t.min = this.getMin().orElse(null);
        t.nulled = java.util.Optional.ofNullable(this.isNulled()).map(a -> a.toString()).orElse(null);
        t.uniqueValuesCount = this.getUniqueValuesCount().map(i -> i.toString()).orElse(null);
        t.parent = this.getParent().orElse(null);
      }
    }
    ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    private org.infrastructurebuilder.data.IBDataStructuredDataMetadata parent = null;
    @Override
    public java.util.Optional<org.infrastructurebuilder.data.IBDataStructuredDataMetadata> getParent() {
      return java.util.Optional.ofNullable(this.parent);
    }
    @Override
    public void setParent(org.infrastructurebuilder.data.IBDataStructuredDataMetadata parent) {
      this.parent = parent;
    }
    ]]>

          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public java.util.Optional<String> getMax() {
        return java.util.Optional.ofNullable(this.max);
    }

    public java.util.Optional<String> getMin() {
        return java.util.Optional.ofNullable(this.min);
    }

    public java.util.Optional<Integer> getUniqueValuesCount() {
      return java.util.Optional.ofNullable(this.uniqueValuesCount).map(Integer::parseInt);
    }

    public java.util.Optional<Boolean> isNulled() {
      return java.util.Optional.ofNullable(this.nulled).map(f -> "true".equalsIgnoreCase(f));
    }
    ]]>

          </code>
        </codeSegment>
        <codeSegment>
        <code>
        <![CDATA[
            @Override
    public String toString() {
      StringBuilder builder = new StringBuilder();
      builder.append("StructuredFieldMetadata [index=").append(index).append(", max=").append(max).append(", min=")
          .append(min).append(", nulled=").append(nulled).append(", uniqueValuesCount=").append(uniqueValuesCount)
          .append("]");
      return builder.toString();
    }

        ]]></code>
        </codeSegment>
      </codeSegments>
    </class>

    <class xml.tagName="dataStreamStructuredMetadata"
      java.clone.hook="mutatingDataStreamStructuredMetadataCloneHook"
      java.clone="deep">
      <name>DataStreamStructuredMetadata</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataStructuredDataMetadata]]>
        </interface>
      </interfaces>
      <fields>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the datastream that this metadata references</description>
          <type>String</type>
        </field>
        <field>
          <name>fields</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>List of structured data for a given field. </description>
          <association>
            <type>StructuredFieldMetadata</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

            // Default constructor (required because we're making a new one)
  public DataStreamStructuredMetadata() {
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Copy constructor
  public DataStreamStructuredMetadata(org.infrastructurebuilder.data.IBDataStructuredDataMetadata o) {
    this.uuid = o.getUuid();
    this.mutatingDataStreamStructuredMetadataCloneHook(o);
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  public void mutatingDataStreamStructuredMetadataCloneHook(org.infrastructurebuilder.data.IBDataStructuredDataMetadata s) {
    this.fields = s.getFields().stream().map(StructuredFieldMetadata::new).collect(java.util.stream.Collectors.toList());
    this.parent = s.getParent().orElse(null);
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    private org.infrastructurebuilder.data.IBDataStream parent = null;
    @Override
    public java.util.Optional<org.infrastructurebuilder.data.IBDataStream> getParent() {
      return java.util.Optional.ofNullable(this.parent);
    }
    public void setParent(org.infrastructurebuilder.data.IBDataStream parent) {
      this.parent = parent;
    }
    ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    @Override
    public int hashCode() {
      return java.util.Objects.hash(fields, uuid, parent);
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      DataStreamStructuredMetadata other = (DataStreamStructuredMetadata) obj;
      return java.util.Objects.equals(fields, other.fields)
        && java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(parent, other.parent)
        ;
    }

    ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>

    <class xml.tagName="dataStreamProvenance"
      java.clone.hook="mutatingDataStreamProvenanceCloneHook"
      java.clone="deep">
      <name>DataStreamProvenance</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataProvenance]]>
        </interface>
      </interfaces>
      <fields>
        <field>
          <name>originator</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>UUID identifier of the datastream that this metadata references</description>
          <association>
            <type>Dependency</type>
            <multiplicity>1</multiplicity>
          </association>
        </field>
        <field>
          <name>url</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description> Originating URL</description>
          <type>String</type>
        </field>
        <field>
          <name>transformations</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>List of structured data for a given field. </description>
          <association>
            <type>String</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

            // Default constructor (required because we're making a new one)
  public DataStreamProvenance() {
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
    * Copy constructor
    */
  public DataStreamProvenance(org.infrastructurebuilder.data.IBDataProvenance o) {
    this();
    this.setOriginator(o.getOriginalSourceArtifact().map(Dependency::new).orElse(null));
    this.url = o.getOriginalURL().orElse(null);
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  public void mutatingDataStreamProvenanceCloneHook(DataStreamProvenance s) {
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // HASH


  @Override
  public int hashCode() {
    return java.util.Objects.hash(originator, transformations, url);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    DataStreamProvenance other = (DataStreamProvenance) obj;
    return java.util.Objects.equals(originator, other.originator)
        && java.util.Objects.equals(transformations, other.transformations)
        && java.util.Objects.equals(url, other.url);
  }

  @Override
  public String toString() {
    return "DataStreamProvenance [originator=" + originator + ", url=" + url + ", transformations=" + transformations
        + "]";
  }

  // Implement required methods
  @Override
  public java.util.Optional<org.infrastructurebuilder.util.artifacts.GAV> getOriginalSourceArtifact() {
    return java.util.Optional.ofNullable(getOriginator()).map(Dependency::asGAV);
  }

  @Override
  public java.util.Optional<String> getOriginalURL() {
    return java.util.Optional.ofNullable(getUrl());
  }

  @Override
  public java.util.Optional<java.util.List<String>> getTransformationList() {
    return java.util.Optional.ofNullable(this.transformations);
  }

    ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class xml.tagName="gav" java.clone="deep">
      <name>Dependency</name>
      <version>1.0.0+</version>
      <fields>
        <field>
          <name>groupId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Group ID</description>
          <type>String</type>
        </field>
        <field>
          <name>artifactId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>ArtifactId ID</description>
          <type>String</type>
        </field>
        <field>
          <name>version</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>version</description>
          <type>String</type>
        </field>
        <field>
          <name>extension</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>extension (not type-mapped)</description>
          <type>String</type>
        </field>
        <field>
          <name>classifier</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Addl classifier</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

  public Dependency() {
  }
  public Dependency(org.infrastructurebuilder.util.artifacts.GAV g) {
    this.groupId = g.getGroupId();
    this.artifactId = g.getArtifactId();
    this.version = g.getVersion().orElse(null);
    this.classifier = g.getClassifier().orElse(null);
    this.extension = g.getExtension();
  }


  @Override
    public int hashCode() {
      return java.util.Objects.hash(groupId, artifactId, classifier, extension, version);
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      Dependency other = (Dependency) obj;
      return
             java.util.Objects.equals(groupId, other.groupId)
          && java.util.Objects.equals(artifactId, other.artifactId)
          && java.util.Objects.equals(classifier, other.classifier)
          && java.util.Objects.equals(extension, other.extension)
          && java.util.Objects.equals(version, other.version);
    }

  @Override
    public String toString() {
      return "Dependency [groupId=" + groupId + ", artifactId=" + artifactId + ", version=" + version + ", extension="
          + extension + ", classifier=" + classifier + "]";
    }

  public org.infrastructurebuilder.util.artifacts.GAV asGAV() {
    return new org.infrastructurebuilder.util.artifacts.impl.DefaultGAV(groupId, artifactId, classifier, version, extension);
  }
    ]]>
          </code>
        </codeSegment>

      </codeSegments>
    </class>


    <class xml.tagName="schema"
      java.clone.hook="mutatingDataSchemaCloneHook" java.clone="deep">
      <name>DataSchema</name>
      <version>1.0.0+</version>
      <description>
        <![CDATA[
        The <code>&lt;schema&gt;</code> element contains information about a single schema.
        ]]>
      </description>
      <interfaces>
        <interface>org.infrastructurebuilder.data.IBDataSchemaIdentifier</interface>
      </interfaces>
      <fields>
        <field java.getter="false">
          <name>uuid</name>
          <version>1.0.0+</version>
          <description>Identifier.  During ingestion, this is NOT a uuid.</description>
          <required>true</required>
          <type>String</type>
        </field>
        <field>
          <name>schemaType</name>
          <association>
            <type>SchemaType</type>
            <multiplicity>1</multiplicity>
          </association>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Type of schema.  This is the component hint used to lookup the provider.</description>
        </field>
        <field>
          <name>name</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the DataSchema.</description>
          <type>String</type>
        </field>
        <field>
          <name>description</name>
          <version>1.0.0+</version>
          <description>A detailed description of the DataSchema</description>
          <required>true</required>
          <type>String</type>
        </field>
        <field xml.format="yyyy-MM-dd'T'HH:mm:ss.SSS">
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Creation date of this stream, required</description>
          <type>Date</type>
        </field>
        <field>
          <name>sha512</name>
          <version>1.0.0+</version>
          <description>Persisted value of computed checksum</description>
          <required>true</required>
          <type>String</type>
        </field>

        <field java.getter="false">
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
        <field java.getter="false">
          <name>schemaAssets</name>
          <version>1.0.0+</version>
          <association>
            <type>SchemaAsset</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
    Default constructor
  */
  public DataSchema() {
    this.setCreationDate(new java.util.Date());
    this.setSchemaType(new SchemaType());
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   "Copy constructor"
   */
  public DataSchema(org.infrastructurebuilder.data.IBDataSchemaIdentifier  ds) {
    this(
      new SchemaType(
      java.util.Objects.requireNonNull(ds).getSchemaType())
      , ds.getName()
      , ds.getDescription()
      , ds.getCreationDate()
      , new org.infrastructurebuilder.data.Metadata(ds.getMetadata())
      , ds.getSchemaAssets().stream().map(SchemaAsset::new).collect(java.util.stream.Collectors.toList()));
  }

            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   "(Most) Data constructor"
   */
  public DataSchema(
    SchemaType type
    ,String name
    ,String description
    ,java.util.Date creationDate
    ,org.infrastructurebuilder.data.Metadata metadata
    ,java.util.List<SchemaAsset> schemaAssets
    ) {
    // this.setUuid(null); // Handled (AND ERASED) by clone hook, as well as sha512
    this.setSchemaType(type);
    this.setCreationDate(creationDate);
    this.setDescription(description);
    this.setName(name);
    this.setMetadata(metadata);
    mutatingDataSchemaCloneHook(this);
  }

            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

  /**
    * Clone hook. The contract is that you must write a <code>.clone()</code> of the
    * DataSchema
    */
  private void mutatingDataSchemaCloneHook(DataSchema s) {
    org.infrastructurebuilder.util.artifacts.Checksum c = s.asChecksum();
    s.setSha512(c.toString());
    s.setUuid(c.asUUID().get().toString());
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   * Get the UUID as a string for matching purposes
   */
  public String getId() {
    return this.uuid;
  }
  @Override
  public int hashCode() {
    return java.util.Objects.hash(creationDate, description, uuid, metadata,  name, schemaType, sha512);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof DataSchema)) {
      return false;
    }
    DataSchema other = (DataSchema) obj;
    return java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(description, other.description)
        && java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(metadata, other.metadata)
        && java.util.Objects.equals(name, other.name)
        && java.util.Objects.equals(schemaType, other.schemaType)
        && java.util.Objects.equals(sha512, other.sha512)
        ;
  }


  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("DataSchema [uuid=").append(uuid).append(", schemaType=").append(schemaType)
        .append(", name=").append(name).append(", description=").append(description)
        .append(", creationDate=").append(creationDate).append(", metadata=").append(metadata)
        .append(", sha512=").append(sha512)
        .append("]");
    return builder.toString();
  }

  @Override
  public  java.util.List<org.infrastructurebuilder.data.IBDataSchemaAsset> getSchemaAssets() {
    if (this.schemaAssets == null)
      this.schemaAssets = new java.util.ArrayList<>();
    return this.schemaAssets.stream().collect(java.util.stream.Collectors.toList());
  }

            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  private String temporaryId;  // Never persisted
  /**
   * Set a temporary value to the UUID field for processing
   */
  public void setTemporaryId(String id) {
    this.temporaryId = id;
  }

  public java.util.Optional<String> getTemporaryId() {
    return java.util.Optional.ofNullable(this.temporaryId);
  }

              ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

  @Override
  public java.util.UUID getUuid() {
    return java.util.Optional.ofNullable(getSha512()).map(java.util.UUID::fromString).orElse(null);
  }

  @Override
  public org.infrastructurebuilder.data.Metadata getMetadata() {
      if (this.metadata == null)
         this.metadata = new org.infrastructurebuilder.data.Metadata();
      if (!(this.metadata instanceof org.infrastructurebuilder.data.Metadata))
        this.metadata = new org.infrastructurebuilder.data.Metadata(this.metadata);
      return (org.infrastructurebuilder.data.Metadata) this.metadata;
  }


              ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   * Return a sorted set of the schema fields
   */
//  @Override
//  public java.util.SortedSet<org.infrastructurebuilder.data.IBField> getSchemaFields() {
//    return getFields().stream().sorted().collect(java.util.stream.Collectors.toCollection(java.util.TreeSet::new));
//  }
              ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
//  public java.util.Optional<org.infrastructurebuilder.data.IBDataStructuredDataMetadata> getStructuredDataMetadata() {
//    return java.util.Optional.ofNullable(this.getStructuredDataDescriptor());
//  }            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>

    <class xml.tagName="asset" java.clone="deep">
      <name>SchemaAsset</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>org.infrastructurebuilder.data.IBDataSchemaAsset</interface>
      </interfaces>
      <fields>
        <field>
          <name>id</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Schema technology identifier (component hint)</description>
          <type>String</type>
        </field>
        <field>
          <name>sha512</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Technology underlying the schema management</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
              <![CDATA[

  public SchemaAsset() {
  }
  public SchemaAsset(org.infrastructurebuilder.data.IBDataSchemaAsset g) {
    this(g.getId(), g.getSha512());
  }
  public SchemaAsset(String id, String sha512) {
    this();
    this.id = java.util.Objects.requireNonNull(id);
    this.sha512 = java.util.Objects.requireNonNull(sha512);

  }


  @Override
    public int hashCode() {
      return java.util.Objects.hash(id, sha512);
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      SchemaAsset other = (SchemaAsset) obj;
      return
             java.util.Objects.equals(id, other.id)
          && java.util.Objects.equals(sha512, other.sha512)
          ;
    }


    ]]>
          </code>
        </codeSegment>

      </codeSegments>
    </class>

    <class xml.tagName="schemaType" java.clone="deep">
      <name>SchemaType</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>org.infrastructurebuilder.data.IBSchemaType</interface>
      </interfaces>
      <fields>
        <field>
          <name>type</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Schema technology identifier (component hint)</description>
          <type>String</type>
        </field>
        <field>
          <name>technology</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Technology underlying the schema management</description>
          <type>String</type>
        </field>
        <field java.getter="false">
          <name>versionedProvider</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Identifier for the underlying provider's artifact</description>
          <type>String</type>
        </field>
      </fields>
      <!-- Code Segments generated in ibdata-schema.mdo -->
    </class>

  </classes>
</model>