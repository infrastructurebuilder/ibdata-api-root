<model xmlns="http://codehaus-plexus.github.io/MODELLO/1.8.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://codehaus-plexus.github.io/MODELLO/1.8.0 http://codehaus-plexus.github.io/modello/xsd/modello-1.8.0.xsd"
  java.suppressAllWarnings="false"
  xml.namespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}"
  xml.schemaLocation="https://resources.infrastructurebuilder.org/xsd/IBDataSet-${apiVersion}"
  xsd.namespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}"
  xsd.targetNamespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}">
  <id>datasource</id>
  <name>IBDataSourceModel</name>
  <!-- Must be a single (no spaces, no dashes, no periods) identifier in
    order to create reader/writer -->
  <description>Mechanism to read config for an IBDataSource</description>
  <defaults>
    <default>
      <key>package</key>
      <value>${project.groupId}.model</value>
    </default>
  </defaults>
  <versionDefinition>
    <type>field</type>
    <value>modelVersion</value>
  </versionDefinition>
  <classes>
    <!-- MODEL -->
    <class xml.tagName="dataSet" rootElement="true"
      java.clone.hook="mutatingDataSetCloneHook" java.clone="deep">
      <name>DataSet</name>
      <description>
        <![CDATA[
        The <code>&lt;dataSet&gt;</code> element is the root of the configuration.
        ]]>
      </description>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataSetIdentifier]]>
        </interface>
        <interface>
          <![CDATA[java.lang.Comparable<org.infrastructurebuilder.data.IBDataSetIdentifier>]]>
        </interface>
      </interfaces>
      <fields>

        <!-- ====================================================================== -->
        <!-- Deployment Version -->
        <!-- ====================================================================== -->
        <field>
          <name>modelVersion</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Declares to which version of project descriptor this configuration conforms.  This value is the api version (major.minor) of ibdata-api and conforms to semantic versioning</description>
          <type>String</type>
        </field>


        <field>
          <name>groupId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Namespace of the dataset.  This defaults to the project.groupId of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>artifactId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Artifact Identifier of the dataset.  This defaults to the project.artifactId of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>version</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Version of the dataset.  This defaults to the project.version of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the dataset.  This is the UUID from the Checksums of all the DataStream elements</description>
          <type>String</type>
        </field>
        <field>
          <name>dataSetName</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the dataset.  This defaults to the project.name of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>dataSetDescription</name>
          <version>1.0.0+</version>
          <description>A detailed description of the dataset.  This defaults to the project.description of the building project</description>
          <type>String</type>
        </field>
        <field xml.format="yyyy-MM-dd'T'HH:mm:ss.SSS">
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>A Date that is very close to the moment when this DataSet was persisted.  It has essentially no relationship to when the streams were read, except that it must be later.</description>
          <type>Date</type>
        </field>
        <field>
          <name>streams</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Instances of DataStreams</description>
          <association>
            <type>DataStream</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field>
          <name>schemas</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Instances of DataSchema</description>
          <association>
            <type>DataSchema</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field>
          <name>path</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes a path to the dataset</description>
          <type>String</type>
        </field>
        <field>
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
      </fields>
      <codeSegments>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Default constructor (Must do this if you supply a constructor)
  public DataSet() {
    setCreationDate(new java.util.Date());
    setStreams(new java.util.ArrayList<>());
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Copy constructor
  public DataSet(DataSet ds) {
    this.setArtifactId(ds.getArtifactId());
    this.setCreationDate(ds.getCreationDate());
    this.setDataSetDescription(ds.getDataSetDescription());
    this.setDataSetName(ds.getDataSetName());
    this.setGroupId(ds.getGroupId());
    this.setMetadata(ds.getMetadata());
    this.setModelVersion(ds.getModelVersion());
    this.setPath(ds.getPath());
    this.setStreams(ds.getStreams().stream().map(DataStream::new).collect(java.util.stream.Collectors.toList()));
    this.setUuid(ds.getUuid());
    this.setVersion(ds.getVersion());
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  private void mutatingDataSetCloneHook(DataSet ds) {
    if (streams != null)
      ds.getStreams().forEach(s -> s.setPath(org.infrastructurebuilder.data.IBDataModelUtils.relativizePath(ds, s)));
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  private java.nio.file.Path underlyingPath = null;

  protected DataSet setUnderlyingPath(java.nio.file.Path p) {
    this.underlyingPath = p;
    return this;
  }

  protected java.util.Optional<java.nio.file.Path> underLyingPath() {
    return java.util.Optional.ofNullable(underlyingPath);
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Hashcode and equals
  @Override
  public int hashCode() {
    return java.util.Objects.hash(artifactId, creationDate, dataSetDescription, dataSetName, groupId, metadata, modelEncoding,
        modelVersion, path, streams, uuid, version);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    DataSet other = (DataSet) obj;
    return java.util.Objects.equals(artifactId, other.artifactId)
        && java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(dataSetDescription, other.dataSetDescription)
        && java.util.Objects.equals(dataSetName, other.dataSetName)
        && java.util.Objects.equals(groupId, other.groupId)
        && java.util.Objects.equals(metadata, other.metadata)
        && java.util.Objects.equals(modelEncoding, other.modelEncoding)
        && java.util.Objects.equals(modelVersion, other.modelVersion)
        && java.util.Objects.equals(path, other.path)
        && java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(version, other.version)
        && java.util.Objects.equals(streams, other.streams)
        ;
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getName() {
    return java.util.Optional.ofNullable(getDataSetName());
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getDescription() {
    return java.util.Optional.ofNullable(getDataSetDescription());
  }

  ]]>
          </code>
        </codeSegment>



        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int compareTo(org.infrastructurebuilder.data.IBDataSetIdentifier that) {
    return IBDataSetIdentifierComparator.compare(this, that);
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            //
            // ID mapper Work
            //
  @Override
  public java.util.UUID getId() {
     return nullableSafeMapUUID.apply(getUuid());
  }            ]]>
          </code>
        </codeSegment>
      </codeSegments>

    </class>
    <class xml.tagName="dataStream"
      java.clone.hook="mutatingDataStreamCloneHook" java.clone="deep">
      <name>DataStream</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataStreamIdentifier]]>
        </interface>
        <interface>
          <![CDATA[java.lang.Comparable<org.infrastructurebuilder.data.IBDataStreamIdentifier>]]>
        </interface>
      </interfaces>
      <description>
        <![CDATA[
        The <code>&lt;dataSet&gt;</code> element contains information about a set of DataStream instances.
        ]]>
      </description>
      <fields>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the datastream, which is the UUID of the bytes of the checksum of the data.</description>
          <type>String</type>
        </field>
        <field>
          <name>dataStreamName</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the datastream.</description>
          <type>String</type>
        </field>
        <field>
          <name>dataStreamDescription</name>
          <version>1.0.0+</version>
          <description>A detailed description of the datastream</description>
          <type>String</type>
        </field>
        <field>
          <name>mimeType</name>
          <version>1.0.0+</version>
          <description>Stringified version of a MIME type for the datastream</description>
          <required>true</required>
          <defaultValue>application/octet-stream</defaultValue>
          <type>String</type>
        </field>
        <field>
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Creation date of this stream, required</description>
          <type>Date</type>
        </field>
        <field>
          <name>sourceURL</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>URL of the source of this stream, if available</description>
          <type>String</type>
        </field>
        <field>
          <name>sha512</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Sha-512 Checksum  of the source of this stream</description>
          <type>String</type>
        </field>
        <field>
          <name>path</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Describes a path to the stream</description>
          <type>String</type>
        </field>
        <field>
          <name>structuredDataDescriptor</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Optional DataStreamStructuredMetadata element for datastream</description>
          <association>
            <type>DataStreamStructuredMetadata</type>
            <multiplicity>1</multiplicity>
          </association>
        </field>
        <field>
          <name>originalLength</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Length of the original stream, if known</description>
          <type>String</type>
        </field>
        <field>
          <name>originalRowCount</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Number of rows of the stream</description>
          <type>String</type>
        </field>
        <field>
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
        <field xml.tagName="provenance">
          <name>dataStreamProvenance</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Datastream provenance</description>
          <association>
            <type>DataStreamProvenance</type>
            <multiplicity>1</multiplicity>
          </association>
        </field>
        <field>
          <name>referencedSchema</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>UUID of schema that this DataStream is meant to map to</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Default constructor
  public DataStream() {
    this.setCreationDate(new java.util.Date());
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // "Copy constructor"
  public DataStream(DataStream ds) {
    this.setCreationDate(ds.getCreationDate());
    this.setDataStreamDescription(ds.getDataStreamDescription());
    this.setDataStreamName(ds.getDataStreamName());
    this.setMetadata(ds.getMetadata());
    this.setMimeType(ds.getMimeType());
    this.setPath(ds.getPath());
    this.setSha512(ds.getSha512());
    this.setSourceURL(ds.getSourceURL());
    this.setUuid(ds.getUuid());
    this.setOriginalLength(ds.getOriginalLength());
    this.setOriginalRowCount(ds.getOriginalRowCount());
    this.setDataStreamProvenance(ds.getProvenance().map(DataStreamProvenance::new).orElse(null));
    this.setReferencedSchema(ds.getReferencedSchema());
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  private void mutatingDataStreamCloneHook(DataStream s) {
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // hash and equals


  @Override
  public int hashCode() {
    return java.util.Objects.hash(creationDate, dataStreamDescription, dataStreamName, metadata, mimeType, path, sha512,
        sourceURL, uuid, originalLength, originalRowCount, dataStreamProvenance, referencedSchema);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    DataStream other = (DataStream) obj;
    return java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(dataStreamDescription, other.dataStreamDescription)
        && java.util.Objects.equals(dataStreamName, other.dataStreamName) && java.util.Objects.equals(metadata, other.metadata)
        && java.util.Objects.equals(mimeType, other.mimeType) && java.util.Objects.equals(path, other.path)
        && java.util.Objects.equals(sha512, other.sha512) && java.util.Objects.equals(sourceURL, other.sourceURL)
        && java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(originalLength, other.originalLength)
        && java.util.Objects.equals(originalRowCount, other.originalRowCount)
        && java.util.Objects.equals(dataStreamProvenance, other.dataStreamProvenance)
        && java.util.Objects.equals(referencedSchema, other.referencedSchema)
        ;
  }


            ]]>
          </code>
        </codeSegment>


        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int compareTo(org.infrastructurebuilder.data.IBDataStreamIdentifier that) {
    return ibDataStreamComparator.compare(this, that);
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            //
            // ID mapper Work
            //
  @Override
  public java.util.UUID getId() {
     return safeMapUUID.apply(getUuid()).orElse(null);
  }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Typed source url access
  @Override
  public java.util.Optional<String> getURL() {
    return java.util.Optional.ofNullable(getSourceURL());

  }
  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getName() {
    return java.util.Optional.ofNullable(getDataStreamName());
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<org.infrastructurebuilder.data.IBDataProvenance> getProvenance() {
    return java.util.Optional.ofNullable(getDataStreamProvenance());
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getDescription() {
    return java.util.Optional.ofNullable(getDataStreamDescription());
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  public java.util.Optional<org.infrastructurebuilder.data.IBDataStructuredDataMetadata> getStructuredDataMetadata() {
    return java.util.Optional.ofNullable(this.getStructuredDataDescriptor());
  }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   * Fetch the schema ID
   */
  @Override
  public java.util.Optional<java.util.UUID> getReferencedSchemaId() {
    return safeMapUUID.apply(getReferencedSchema());
  }
          ]]>
          </code>
        </codeSegment>

        <!-- <codeSegment> <version>1.0.0+</version> <code> <![CDATA[ private
          java.util.Optional<String> getValidatedSha512() { if (this.sha512 != null
          && this.sha512.length() != 128) throw new org.infrastructurebuilder.data.IBDataException("sha512
          length must be 128 "); return java.util.Optional.ofNullable(getSha512());
          } // Checksum @Override public org.infrastructurebuilder.util.artifacts.Checksum
          getChecksum() { return getValidatedSha512() .map(org.infrastructurebuilder.util.artifacts.Checksum::new)
          .orElseThrow(() -> new org.infrastructurebuilder.data.IBDataException("No
          sha512 available")); } ]]> </code> </codeSegment> -->
      </codeSegments>
    </class>
    <class locationTracker="locations" java.clone="shallow">
      <name>DataSetInputLocation</name>
      <version>1.0.0+</version>
      <fields>
        <!-- line, column and source fields are auto-generated by Modello -->
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

    @Override
    public String toString()
    {
        return getLineNumber() + " : " + getColumnNumber() + ", " + getSource();
    }
            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class sourceTracker="source" java.clone="shallow">
      <name>DataSetInputSource</name>
      <version>1.0.0+</version>
      <fields>
        <field>
          <name>modelId</name>
          <version>1.0.0+</version>
          <type>String</type>
          <description>
            <![CDATA[
            The identifier of the deployment model in the format {@code <groupId>:<artifactId>:<version>}.
            ]]>
          </description>
        </field>
        <field>
          <name>location</name>
          <version>1.0.0+</version>
          <type>String</type>
          <description>
            <![CDATA[
            The path/URL of the deployment model or {@code null} if unknown.
            ]]>
          </description>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    @Override
    public String toString()
    {
        return getModelId() + " " + getLocation();
    }
            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>

    <class xml.tagName="structuredFieldMetadata" java.clone="deep">
      <name>StructuredFieldMetadata</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
                <![CDATA[org.infrastructurebuilder.data.IBDataStructuredDataFieldMetadata]]>
            </interface>
      </interfaces>
      <fields>
        <field>
          <name>index</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Describes the field within the structured metadata that this SFM describes, from a base of 0.  Default value set to -1 to ensure setting proper index</description>
          <type>int</type>
          <defaultValue>-1</defaultValue>
        </field>
        <field>
          <name>metadataType</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>"name()" of an enumerated type from IBDataStructuredDataMetadataType. Not required, but strongly encouraged.</description>
          <type>String</type>
        </field>
        <field>
          <name>enumerations</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Shows the list of (ordinal) enums that this field posseses.  If not present, this is not assumed to not be an enum</description>
          <association>
            <type>String</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field>
          <name>max</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes the "maximum length" or "maximum size" of the data in the field.</description>
          <type>String</type>
        </field>
        <field>
          <name>min</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes the "minimum length" or "maximum size" of the data in the field.</description>
          <type>String</type>
        </field>
        <field>
          <name>nullable</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes if the field has a null value in it.  The only "true" answer is the string 'true'</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public StructuredFieldMetadata() {
    }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public StructuredFieldMetadata(org.infrastructurebuilder.data.IBDataStructuredDataFieldMetadata o) {
      this.index = o.getIndex();
      this.metadataType = o.getMetadataType();
      this.enumerations = new java.util.ArrayList<>(o.getEnumerations().stream().collect(java.util.stream.Collectors.toList()));
      this.max = o.getMax();
      this.min = o.getMin();
      this.nullable = o.getNullable();
    }
    ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public void setType(org.infrastructurebuilder.data.IBDataStructuredDataMetadataType t) {
        this.setMetadataType(java.util.Objects.requireNonNull(t, "IBDataStructuredDataMetadataType is null").name());
    }            ]]>
          </code>
        </codeSegment>

        <!-- <codeSegment> <version>1.0.0+</version> <code> <![CDATA[ //
          Clone hooks private void mutatingDataStreamStructuredMetadataCloneHook(DataStreamStructuredMetadata
          s) { } ]]> </code> </codeSegment> -->
      </codeSegments>
    </class>

    <class xml.tagName="dataStreamStructuredMetadata"
      java.clone.hook="mutatingDataStreamStructuredMetadataCloneHook"
      java.clone="deep">
      <name>DataStreamStructuredMetadata</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataStructuredDataMetadata]]>
        </interface>
      </interfaces>
      <fields>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the datastream that this metadata references</description>
          <type>String</type>
        </field>
        <field>
          <name>fields</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>List of structured data for a given field. </description>
          <association>
            <type>StructuredFieldMetadata</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

            // Default constructor (required because we're making a new one)
  public DataStreamStructuredMetadata() {
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Copy constructor
  public DataStreamStructuredMetadata(org.infrastructurebuilder.data.IBDataStructuredDataMetadata o) {
    this.uuid = o.getUuid();
    this.fields = o.getFields().stream().map(StructuredFieldMetadata::new).collect(java.util.stream.Collectors.toList());
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  public void mutatingDataStreamStructuredMetadataCloneHook(DataStreamStructuredMetadata s) {
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    @Override
    public int hashCode() {
      return java.util.Objects.hash(fields, uuid);
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      DataStreamStructuredMetadata other = (DataStreamStructuredMetadata) obj;
      return java.util.Objects.equals(fields, other.fields) && java.util.Objects.equals(uuid, other.uuid);
    }

    ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>

    <class xml.tagName="dataStreamProvenance"
      java.clone.hook="mutatingDataStreamProvenanceCloneHook"
      java.clone="deep">
      <name>DataStreamProvenance</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataProvenance]]>
        </interface>
      </interfaces>
      <fields>
        <field>
          <name>originator</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>UUID identifier of the datastream that this metadata references</description>
          <association>
            <type>Dependency</type>
            <multiplicity>1</multiplicity>
          </association>
        </field>
        <field>
          <name>url</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description> Originating URL</description>
          <type>String</type>
        </field>
        <field>
          <name>transformations</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>List of structured data for a given field. </description>
          <association>
            <type>String</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

            // Default constructor (required because we're making a new one)
  public DataStreamProvenance() {
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
    * Copy constructor
    */
  public DataStreamProvenance(org.infrastructurebuilder.data.IBDataProvenance o) {
    this();
    this.setOriginator(o.getOriginalSourceArtifact().map(Dependency::new).orElse(null));
    this.url = o.getOriginalURL().orElse(null);
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  public void mutatingDataStreamProvenanceCloneHook(DataStreamProvenance s) {
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // HASH


  @Override
  public int hashCode() {
    return java.util.Objects.hash(originator, transformations, url);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    DataStreamProvenance other = (DataStreamProvenance) obj;
    return java.util.Objects.equals(originator, other.originator)
        && java.util.Objects.equals(transformations, other.transformations)
        && java.util.Objects.equals(url, other.url);
  }

  @Override
  public String toString() {
    return "DataStreamProvenance [originator=" + originator + ", url=" + url + ", transformations=" + transformations
        + "]";
  }

  // Implement required methods
  @Override
  public java.util.Optional<org.infrastructurebuilder.util.artifacts.GAV> getOriginalSourceArtifact() {
    return java.util.Optional.ofNullable(getOriginator()).map(Dependency::asGAV);
  }

  @Override
  public java.util.Optional<String> getOriginalURL() {
    return java.util.Optional.ofNullable(getUrl());
  }

  @Override
  public java.util.Optional<java.util.List<String>> getTransformationList() {
    return java.util.Optional.ofNullable(this.transformations);
  }

    ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class xml.tagName="gav" java.clone="deep">
      <name>Dependency</name>
      <version>1.0.0+</version>
      <fields>
        <field>
          <name>groupId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Group ID</description>
          <type>String</type>
        </field>
        <field>
          <name>artifactId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>ArtifactId ID</description>
          <type>String</type>
        </field>
        <field>
          <name>version</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>version</description>
          <type>String</type>
        </field>
        <field>
          <name>extension</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>extension (not type-mapped)</description>
          <type>String</type>
        </field>
        <field>
          <name>classifier</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Addl classifier</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

  public Dependency() {
  }
  public Dependency(org.infrastructurebuilder.util.artifacts.GAV g) {
    this.groupId = g.getGroupId();
    this.artifactId = g.getArtifactId();
    this.version = g.getVersion().orElse(null);
    this.classifier = g.getClassifier().orElse(null);
    this.extension = g.getExtension();
  }


  @Override
    public int hashCode() {
      return java.util.Objects.hash(artifactId, classifier, extension, groupId, version);
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      Dependency other = (Dependency) obj;
      return java.util.Objects.equals(artifactId, other.artifactId) && java.util.Objects.equals(classifier, other.classifier)
          && java.util.Objects.equals(extension, other.extension) && java.util.Objects.equals(groupId, other.groupId)
          && java.util.Objects.equals(version, other.version);
    }

  @Override
    public String toString() {
      return "Dependency [groupId=" + groupId + ", artifactId=" + artifactId + ", version=" + version + ", extension="
          + extension + ", classifier=" + classifier + "]";
    }

  public org.infrastructurebuilder.util.artifacts.GAV asGAV() {
    return new org.infrastructurebuilder.util.artifacts.impl.DefaultGAV(groupId, artifactId, classifier, version, extension);
  }
    ]]>
          </code>
        </codeSegment>

      </codeSegments>
    </class>
    <class xml.tagName="schema"
      java.clone.hook="mutatingDataSchemaCloneHook" java.clone="deep">
      <name>DataSchema</name>
      <version>1.0.0+</version>
      <description>
        <![CDATA[
        The <code>&lt;schema&gt;</code> element contains information about a single schema.
        ]]>
      </description>
      <interfaces>
        <interface>org.infrastructurebuilder.data.IBSchema</interface>
      </interfaces>
      <fields>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the DataSchema, which is the UUID from the checksum of the checksums of the other fields in the schema.</description>
          <type>String</type>
        </field>
        <field>
          <name>name</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the DataSchema.</description>
          <type>String</type>
        </field>
        <field>
          <name>description</name>
          <version>1.0.0+</version>
          <description>A detailed description of the DataSchema</description>
          <required>true</required>
          <type>String</type>
        </field>
        <field xml.format="yyyy-MM-dd'T'HH:mm:ss.SSS">
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Creation date of this stream, required</description>
          <type>Date</type>
        </field>
        <field>
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
        <field>
          <name>fields</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Fields of this structure</description>
          <association>
            <type>SchemaField</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field>
          <name>forcedMap</name>
          <version>1.0.0+</version>
          <description>A uuid that indicates a DataStream element that holds a specific impl of a schema for this schema.
            This allows one to override the generated schema (which we strongly recommend against) in favor of a type-specific
            schema to be supplied to the underlying type
            </description>
          <required>false</required>
          <association>
            <multiplicity>*</multiplicity>
            <type>ForcedMapping</type>
          </association>
        </field>

      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
    Default constructor
  */
  public DataSchema() {
    this.setCreationDate(new java.util.Date());
    this.setFields(new java.util.ArrayList<>());
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   "Copy constructor"
   */
  public DataSchema(DataSchema ds) {
    this.setCreationDate(ds.getCreationDate());
    this.setDescription(ds.getDescription());
    this.setName(ds.getName());
    this.setMetadata(ds.getMetadata());
    this.setFields(ds.getFields().stream().map(SchemaField::new).collect(java.util.stream.Collectors.toList()));
    this.setUuid(ds.getUuid());
    mutatingDataSchemaCloneHook(this);
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
    Translate forcedMap to getForcedMapping
  */
  public java.util.Map<String,java.util.UUID> getForcedMapping() {
    return getForcedMap().stream().collect(java.util.stream.Collectors.toMap(ForcedMapping::getType, ForcedMapping::getUUID));
  }
            ]]>
          </code>
        </codeSegment>


        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

  /**
    * Clone hook. The contract is that you must write a <code>.clone()</code> of the
    * DataSchemaSet
    */
  private void mutatingDataSchemaCloneHook(DataSchema s) {
    if ( this.fields != null )
    {
        for ( int i = 0; i < s.fields.size(); ++i )
        {
          s.fields.get(i).setIndex(i);
        }
    }
    s.setUuid(s.asChecksum().get().get().toString());
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int hashCode() {
    return java.util.Objects.hash(uuid, name, creationDate, description, fields, metadata);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    DataSchema other = (DataSchema) obj;
    return
           java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(name, other.name)
        && java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(description, other.description)
        && java.util.Objects.equals(fields, other.fields)
        && java.util.Objects.equals(metadata, other.metadata)
        ;
  }

  @Override
  public String toString() {
    return "DataSchema [uuid=" + uuid + ", name=" + name + ", description=" + description + ", creationDate="
        + creationDate + ", metadata=" + metadata + ", fields=" + fields + "]";
  }


            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   * @return the UUID from this schema uuid string field (or null)
   */
  @Override
  public java.util.UUID getId() {
     return safeMapUUID.apply(getUuid()).orElse(null);
  }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
   * Return a sorted set of the schema fields
   */
  @Override
  public java.util.SortedSet<org.infrastructurebuilder.data.IBField> getSchemaFields() {
    return getFields().stream().sorted().collect(java.util.stream.Collectors.toCollection(java.util.TreeSet::new));
  }
              ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
//  public java.util.Optional<org.infrastructurebuilder.data.IBDataStructuredDataMetadata> getStructuredDataMetadata() {
//    return java.util.Optional.ofNullable(this.getStructuredDataDescriptor());
//  }            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class xml.tagName="forcedMapping" java.clone="deep">
      <name>ForcedMapping</name>
      <version>1.0.0+</version>
      <description>Force a mapping between a schema and a datastream AS A TYPE-SPECIFIC-SCHEMA</description>
      <fields>
        <field>
          <name>type</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The "type" of the schema.  This must conform to some known type provider's component hint.</description>
          <type>String</type>
        </field>
        <field>
          <name>schemaUUID</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID of an existing DataStream that holds the schema for that provider for this Schema instance</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  public java.util.UUID getUUID() {
    return org.infrastructurebuilder.util.artifacts.ChecksumEnabled.nullableSafeMapUUID.apply(getSchemaUUID());
  }
            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class xml.tagName="field"
      java.clone.hook="mutatingSchemaFieldCloneHook" java.clone="deep">
      <name>SchemaField</name>
      <version>1.0.0+</version>
      <description>
        <![CDATA[
        The <code>&lt;schema&gt;</code> element contains information about a single schema.
        ]]>
      </description>
      <interfaces>
        <interface>org.infrastructurebuilder.data.IBField</interface>
      </interfaces>
      <fields>
        <field>
          <name>index</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Describes the IBfield from a base of 0.  Default value set to -1 to ensure setting proper index.  Indices are
            forced reset prior to persistence.</description>
          <type>int</type>
          <defaultValue>-1</defaultValue>
        </field>
        <field>
          <name>name</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the SchemaField.  This name may be munged during translation.</description>
          <type>String</type>
        </field>
        <field>
          <name>description</name>
          <version>1.0.0+</version>
          <description>A detailed description of the SchemaField</description>
          <type>String</type>
        </field>
        <field>
          <name>type</name>
          <description>Value must match the typing enumeration in IBData (currently found in IBDataStructuredDataMetadataType).

          The default value (STREAM) indicates that this schema denotes a single file that is a stream of bytes, and that that
          is the most structure that can be inferred.  Due to the nature of STREAM, it is very important to correctly
          set the SchemaField type.</description>
          <type>String</type>
          <required>true</required>
          <defaultValue>STREAM</defaultValue>
        </field>
        <field>
          <name>nullable</name>
          <description>If true, then this field is allowed to be null.</description>
          <type>boolean</type>
          <required>true</required>
          <defaultValue>false</defaultValue>
        </field>
        <field>
          <name>enumerations</name>
          <description>List of named enumerations for this field.</description>
          <association>
            <type>String</type>
            <multiplicity>*</multiplicity>
          </association>
          <required>false</required>
        </field>
        <field>
          <name>versionAppeared</name>
          <description>version where this SchemaField became valid.  Versions should be truncated to api version.
              This field is required when updating a schema to a new version.</description>
          <type>String</type>
          <required>false</required>
        </field>
        <field>
          <name>deprecated</name>
          <description>If set to true, this SchemaField is deprecated.

          Schema deprecation is different than language deprecation.

          A deprecated field is not represented in outbound
          schema, but might be accepted as inbound schema.  Deprecation definitely means different things to different
          underlying providers, but it may (likely) not be possible to back out a deprecation.

          For some providers, the only means of moving forward is to re-add
          the field as a new field with a later "versionAppeared".</description>
          <type>boolean</type>
          <required>false</required>
        </field>
        <field>
          <name>versionDeprecated</name>
          <description>version where this SchemaField became invalid.  Versions should be truncated to api version.
              This field is required when producing a deprecation (note that a non-null value here does not indicate a
              deprecation.  The flag must still be set in order to deprecate).</description>
          <type>String</type>
          <required>false</required>
        </field>
        <field>
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
    * Default constructore
    */
  public SchemaField() {
    this.setMetadata(new org.codehaus.plexus.util.xml.Xpp3Dom("metadata"));
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  /**
    * Copy constructor (should match clone)
    */
  public SchemaField(SchemaField ds) {
    this.setIndex(ds.getIndex());
    this.setName(ds.getName());
    this.setDescription(ds.getDescription());
    this.setType(ds.getType());
    this.setNullable(ds.isNullable());
    this.setEnumerations(java.util.Optional.ofNullable(getEnumerations()).map(e -> e.stream().collect(java.util.stream.Collectors.toList())).orElse(null));
    this.setVersionAppeared(ds.getVersionAppeared());
    this.setDeprecated(ds.isDeprecated());
    this.setVersionDeprecated(ds.getVersionDeprecated());
    this.setMetadata(ds.getMetadata());
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  private void mutatingSchemaFieldCloneHook(SchemaField s) {
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int hashCode() {
    return java.util.Objects.hash(index,name, description, type, nullable, enumerations, versionAppeared, deprecated, versionDeprecated, metadata);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    SchemaField other = (SchemaField) obj;
    return
           java.util.Objects.equals(index, other.index)
        && java.util.Objects.equals(name, other.name)
        && java.util.Objects.equals(description, other.description)
        && java.util.Objects.equals(type, other.type)
        && java.util.Objects.equals(nullable, other.nullable)
        && java.util.Objects.equals(enumerations, other.enumerations)
        && java.util.Objects.equals(versionAppeared, other.versionAppeared)
        && java.util.Objects.equals(deprecated, other.deprecated)
        && java.util.Objects.equals(versionDeprecated, other.versionDeprecated)
        && java.util.Objects.equals(metadata, other.metadata)
        ;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder
      .append("SchemaField [")
      .append("index=").append(index)
      .append(", name=").append(name)
      .append(", description=").append(description)
      .append(", type=").append(type)
      .append(", nullable=").append(nullable)
      .append(", enumerations=").append(enumerations)
      .append(", versionAppeared=").append(versionAppeared)
      .append(", deprecated=").append(deprecated)
      .append(", versionDeprecated=").append(versionDeprecated)
      .append(", metadata=").append(metadata)
      .append("]");
    return builder.toString();
  }


            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>

  </classes>
</model>